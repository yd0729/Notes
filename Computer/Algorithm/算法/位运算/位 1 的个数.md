# 位 1 的个数

> #
> [【宫水三叶】一题四解:「位数检查」&「右移统计」&「lowbit」&「分组统计」](https://leetcode-cn.com/problems/number-of-1-bits/solution/yi-ti-san-jie-wei-shu-jian-cha-you-yi-to-av1r/)

## 位数检查

对 `int` 的每一位进行检查，并统计 1 的个数。

```java
public class Solution {
    public int hammingWeight(int n) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            ans += ((n >> i) & 1);
        }
        return ans;
    }
}

```

## 右移统计

通过 `n & 1` 来统计当前 n 的最低位是否为 1，同时每次直接对 n 进行右移并高位补 0。这样可以确保只会循环到最高位的 1 ．

```java
public class Solution {
    public int hammingWeight(int n) {
        int ans = 0;
        while (n != 0) {
            ans += (n & 1);
            n >>>= 1;
        }
        return ans;
    }
}
```

## lowbit

lowbit 只会保留最低位的 1 ，这样就可以只处理 1 的位．

-x 是 x 各位取反再 +1 ，这个操作还原了最低位的 1 和其之后的 0 ，但最低位 1 左侧的全部位都被取反了，再和 x 取并就会全部变 0 ，而最低位 1 及右侧的位被保留下来．

```java
public class Solution {
    public int hammingWeight(int n) {
        int ans = 0;
        for (int i = n; i != 0; i -= lowbit(i)) ans++;
        return ans;
    }
    int lowbit(int x) {
        return x & -x;
    }
}

```

## 分组统计

分治，把 32 位的 `int` 看成数组．

1. 每 1 位中 1 的个数就是数组本身．
2. 统计每 2 位中 1 的个数．
3. 统计每 4 位中 1 的个数．
3. 统计每 8 位中 1 的个数．
4. 统计每 16 位中 1 的个数．
5. 统计每 32 位中 1 的个数．

```java
public class Solution {
    public int hammingWeight(int n) {
        n = (n & 0x55555555) + ((n >>> 1)  & 0x55555555);
        n = (n & 0x33333333) + ((n >>> 2)  & 0x33333333);
        n = (n & 0x0f0f0f0f) + ((n >>> 4)  & 0x0f0f0f0f);
        n = (n & 0x00ff00ff) + ((n >>> 8)  & 0x00ff00ff);
        n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);
        return n;
    }
}

```

时间复杂度最低，为 $\log(k)$ ，其中 k = 32 为位数．

这个做法的最大作用，不是处理 `int`，而是处理更大位数的情况，在长度只有 32 位的 `int` 的情况下，该做法不一定就比循环要快（该做法会产生多个的中间结果，导致赋值发生多次，而且由于指令之间存在对 n 数值依赖，可能不会被优化为并行指令），这个道理和对于排序元素少的情况下，我们会选择「选择排序」而不是「归并排序」是一样的。
