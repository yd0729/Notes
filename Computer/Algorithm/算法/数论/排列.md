# 排列

## 排列数 $A_m^n$

```cpp
int numberOfPermutation(int n, int m) {
  int ans = 1;
  while (m--) {
    ans *= n--;
  }
  return ans;
}
```

## 阶乘 $n!$

```cpp
int factorial(int n) {
  int ans = 1;
  while (n) {
    ans *= n--;
  }
  return ans;
}
```

## 不含重复数字的全排列（[LeetCode 46. 全排列](https://leetcode.cn/problems/permutations/)）

把 nums 分成两部分，前半部分是确定的，后半部分是未确定的，每次从未确定位置中选择一个数，和后半部分的第一个数交换，并加入前半部分，这样就能扩大确定的部分，直到获得一个排列．

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        ans.clear();
        int size = nums.size();

        _permute(nums, size, size);

        return ans;
    }
private:
    vector<vector<int>> ans;

    // 在 n 个数中选择 m 个数排列
    void _permute(vector<int> &nums, int n, int m, int pos = 0) {
        if (pos == m) {
            ans.push_back(nums);
        } else {
            for (int i = pos; i < n; i++) {
            swap(nums[pos], nums[i]);  //交换位置，逐步前提
            _permute(nums, n, m, pos + 1);
            swap(nums[pos], nums[i]);  //将位置还回去，对下一次排列负责
            }
        }
    }
};
```

## 可重集全排列（[LeetCode 47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)）

首先 sort ，把重复的数字放在一起，然后用一个 vis 数组记录哪些数被选过了．为了避免在一个位置上选重复的数字，规定重复的数字只能按顺序拿，比如 [... a, b, c ...] ，其中 a = b = c ，那么只有 a 被拿了才能拿 b ，a 和 b 都被拿了才能拿 c ．

如果 n 比较大（10，11），那么这种方法最快．

用一个辅助数组标记数字是否选过的思路比较通用，上一个问题也可以这样做．

```cpp
class Solution {
    vector<bool> vis;
    vector<int> perm;
    vector<vector<int>> ans;

    void backtrack(vector<int>& nums, int idx) {
    if (idx == nums.size()) ans.emplace_back(perm);
    else {
        for (int i = 0; i < nums.size(); ++i) {
            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {
                continue;
            }
            perm.emplace_back(nums[i]);
            vis[i] = true;
            backtrack(nums, idx + 1);
            vis[i] = false;
            perm.pop_back();
        }
    }
}
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vis.resize(nums.size());
        sort(nums.begin(), nums.end());
        backtrack(nums, 0);
        return ans;
    }
};
```

但是如果沿用上个问题中 swap 的思路则会比较困难，因为需要 sort ，而 swap 会改变元素的顺序．但也不是不能实现，好不容易写出来了，仅做记录．

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        ans.clear();
        int size = nums.size();

        sort(nums.begin(), nums.end());
        _permute(nums, size, size);

        return ans;
    }
private:
    vector<vector<int>> ans;

    // 在 n 个数中选择 m 个数排列
    void _permute(vector<int> &nums, int n, int m, int pos = 0) {
        if (pos == m) {
            ans.push_back(nums);
        } else {
            _permute(nums, n, m, pos + 1);
            for (int i = pos + 1; i < n; i++) {
                if (nums[i] == nums[i - 1]) {
                    continue;
                }
                swap(nums[pos], nums[i]);
                int new_i = bubble(nums, pos + 1, n - 1, i);
                _permute(nums, n, m, pos + 1);
                debubble(nums, new_i, i);
                swap(nums[pos], nums[i]);
            }
        }
    }

    // 冒泡到正确的位置
    int bubble(vector<int> &nums, int left, int right, int pos) {
        for (;pos > left and nums[pos] < nums[pos - 1]; --pos) {
            swap(nums[pos], nums[pos - 1]);
        }
        return pos;
    }

    // 放回去
    void debubble(vector<int> &nums, int pos, int old_pos) {
        for (;pos != old_pos; ++pos) {
            swap(nums[pos], nums[pos + 1]);
        }
    }
};
```

## 下一个排列（[LeetCode 31. 下一个排列](https://leetcode.cn/problems/next-permutation/)）

TODO

```cpp

```
