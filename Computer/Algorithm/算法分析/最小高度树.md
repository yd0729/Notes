---
created: 2022-04-06T12:09:55 (UTC +08:00)
source: https://leetcode-cn.com/problems/minimum-height-trees/solution/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f/
publish: true
---

# 最小高度树

## 方法一：广度优先搜索

**思路与算法**

题目中给定的含有 n 个节点的树，可以推出含有以下特征：

- 任意两个节点之间有且仅有一条路径；
- 树中的共有 n−1 条不同的边；
- 叶子节点的度为 1，非叶子节点的度至少为 2；
- 树的高度由根节点到叶子节点的最大距离决定。

最直接的解法是，枚举以每个节点为根构成的树，然后求出该树的高度，所有树的最小高度即为答案，需要的时间复杂度为 $O(n^2)$，在此不再描述。

设 $dist[x][y]$ 表示从节点 x 到节点 y 的距离，假设树中距离最长的两个节点为 $(x,y)$，它们之间的距离为 maxdist\=dist\[x\]\[y\]\\textit{maxdist} = \\textit{dist}\[x\]\[y\]maxdist\=dist\[x\]\[y\]，则可以推出以任意节点构成的树最小高度一定为 minheight\=⌈maxdist2⌉\\textit{minheight} = \\Big \\lceil \\dfrac{\\textit{maxdist}}{2} \\Big \\rceilminheight\=⌈2maxdist⌉，且最小高度的树根节点一定在 节点 xxx 到节点 yyy 的路径上。

- 首先证明树的高度一定为 minheight\=⌈maxdist2⌉\\textit{minheight} = \\Big \\lceil \\dfrac{\\textit{maxdist}}{2} \\Big \\rceilminheight\=⌈2maxdist⌉，可以用反证法证明，假设存在节点 zzz，以节点 zzz 为根的树的高度 h<minheighth < \\textit{minheight}h<minheight，则可以推出：

  - 如果节点 zzz 存在于从 xxx 到 yyy 的路径上，由于 xxx 与 yyy 均为叶子节点，则可以知道 xxx 到 zzz 距离与 yyy 到 zzz 距离均小于 minheight\\textit{minheight}minheight，dist\[x\]\[y\]\=dist\[x\]\[z\]+dist\[z\]\[y\]≤2×⌈dist\[x\]\[y\]2⌉−2<dist\[x\]\[y\]\\textit{dist}\[x\]\[y\] = \\textit{dist}\[x\]\[z\] + \\textit{dist}\[z\]\[y\] \\le 2 \\times \\Big \\lceil \\dfrac{\\textit{dist}\[x\]\[y\]}{2} \\Big \\rceil - 2 < \\textit{dist}\[x\]\[y\]dist\[x\]\[y\]\=dist\[x\]\[z\]+dist\[z\]\[y\]≤2×⌈2dist\[x\]\[y\]⌉−2<dist\[x\]\[y\]，这与 xxx 到 yyy 的距离为 dist\[x\]\[y\]\\textit{dist}\[x\]\[y\]dist\[x\]\[y\] 相矛盾；

  - 如果节点 zzz 不存在于 xxx 到 yyy 的路径上，假设 zzz 到 xxx 的路径为 z→⋯→a→⋯→xz \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow xz→⋯→a→⋯→x，zzz 到 yyy 的路径为 z→⋯→a→⋯→yz \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow yz→⋯→a→⋯→y，这两个路径之间一定存在公共的交叉点，假设交叉点为 aaa，则可以知道此时 zzz 到 xxx 的距离为 dist\[z\]\[x\]\=dist\[z\]\[a\]+dist\[a\]\[z\]\\textit{dist}\[z\]\[x\] = \\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[z\]dist\[z\]\[x\]\=dist\[z\]\[a\]+dist\[a\]\[z\]，zzz 到 yyy 的距离为 dist\[z\]\[y\]\=dist\[z\]\[a\]+dist\[a\]\[y\]\\textit{dist}\[z\]\[y\] = \\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[y\]dist\[z\]\[y\]\=dist\[z\]\[a\]+dist\[a\]\[y\]，由于树的高度小于 h<minheighth < \\textit{minheight}h<minheight，所以可以推出 dist\[z\]\[a\]+dist\[a\]\[x\]<minheight\\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[x\] < \\textit{minheight}dist\[z\]\[a\]+dist\[a\]\[x\]<minheight，dist\[z\]\[a\]+dist\[a\]\[y\]<minheight\\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[y\] < \\textit{minheight}dist\[z\]\[a\]+dist\[a\]\[y\]<minheight，即可以推出 dist\[a\]\[x\]+dist\[a\]\[y\]≤2×minheight−2\=2×⌈dist\[x\]\[y\]2⌉−2<dist\[x\]\[y\]\\textit{dist}\[a\]\[x\] + \\textit{dist}\[a\]\[y\] \\le 2 \\times \\textit{minheight} - 2 = 2 \\times \\Big \\lceil \\dfrac{\\textit{dist}\[x\]\[y\]}{2} \\Big \\rceil - 2 < \\textit{dist}\[x\]\[y\]dist\[a\]\[x\]+dist\[a\]\[y\]≤2×minheight−2\=2×⌈2dist\[x\]\[y\]⌉−2<dist\[x\]\[y\]，这与 xxx 到 yyy 的距离为 dist\[x\]\[y\]\\textit{dist}\[x\]\[y\]dist\[x\]\[y\] 相矛盾；

- 其次证明最小高度树的根节点一定存在于 xxx 到 yyy 的路径上，假设存在节点 zzz 它的最小高度为 minheight\\textit{minheight}minheight，但节点 zzz 不存在于 xxx 到 yyy 之间的路径上：

  - 设 zzz 到 xxx 的路径为 z→⋯→a→⋯→xz \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow xz→⋯→a→⋯→x，zzz 到 yyy 的路径为 z→⋯→a→⋯→yz \\rightarrow \\cdots \\rightarrow a \\rightarrow \\cdots \\rightarrow yz→⋯→a→⋯→y，这两个路径之间一定存在公共的交叉点，假设交叉点为 aaa, 则可以知道此时 zzz 到 xxx 的距离为 dist\[z\]\[x\]\=dist\[z\]\[a\]+dist\[a\]\[z\]\\textit{dist}\[z\]\[x\] = \\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[z\]dist\[z\]\[x\]\=dist\[z\]\[a\]+dist\[a\]\[z\]，zzz 到 yyy 的距离为 dist\[z\]\[y\]\=dist\[z\]\[a\]+dist\[a\]\[y\]\\textit{dist}\[z\]\[y\] = \\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[y\]dist\[z\]\[y\]\=dist\[z\]\[a\]+dist\[a\]\[y\]，由于树的高度小 h\=minheighth = \\textit{minheight}h\=minheight，所以可以推出 dist\[z\]\[a\]+dist\[a\]\[x\]≤minheight\\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[x\] \\le \\textit{minheight}dist\[z\]\[a\]+dist\[a\]\[x\]≤minheight，dist\[z\]\[a\]+dist\[a\]\[y\]≤minheight\\textit{dist}\[z\]\[a\] + \\textit{dist}\[a\]\[y\] \\le \\textit{minheight}dist\[z\]\[a\]+dist\[a\]\[y\]≤minheight，由于 zzz 不在 xxx 到 yyy 的路径上，所以可以知道 dist\[z\]\[a\]≥1\\textit{dist}\[z\]\[a\] \\ge 1dist\[z\]\[a\]≥1，即可以推出 dist\[a\]\[x\]<minheight，dist\[a\]\[y\]<minheight\\textit{dist}\[a\]\[x\] < \\textit{minheight}，\\textit{dist}\[a\]\[y\] < \\textit{minheight}dist\[a\]\[x\]<minheight，dist\[a\]\[y\]<minheight，即可以推出 dist\[a\]\[x\]+dist\[a\]\[y\]≤2×minheight−2\=2×⌈dist\[x\]\[y\]2⌉−2<dist\[x\]\[y\]\\textit{dist}\[a\]\[x\] + \\textit{dist}\[a\]\[y\] \\le 2 \\times \\textit{minheight} - 2 = 2 \\times \\Big \\lceil \\dfrac{\\textit{dist}\[x\]\[y\]}{2} \\Big \\rceil - 2 < \\textit{dist}\[x\]\[y\]dist\[a\]\[x\]+dist\[a\]\[y\]≤2×minheight−2\=2×⌈2dist\[x\]\[y\]⌉−2<dist\[x\]\[y\]，这与 xxx 到 yyy 的距离为 dist\[x\]\[y\]\\textit{dist}\[x\]\[y\]dist\[x\]\[y\] 相矛盾。

综合上述推理，设两个叶子节点的最长距离为 maxdist\\textit{maxdist}maxdist，可以得到结论最小高度树的高度为 ⌈maxdist2⌉\\Big \\lceil \\dfrac{\\textit{maxdist}}{2} \\Big \\rceil⌈2maxdist⌉，且最小高度树的根节点一定存在其最长路径上。假设最长的路径的 mmm 个节点依次为 p1→p2→⋯→pmp_1 \\rightarrow p_2 \\rightarrow \\cdots \\rightarrow p_mp1→p2→⋯→pm，最长路径的长度为 m−1m-1m−1，可以得到以下结论：

- 如果 mmm 为偶数，此时最小高度树的根节点为 pm2p\_{\\frac{m}{2}}p2m 或者 pm2+1p\_{\\frac{m}{2} + 1}p2m+1，且此时最小的高度为 m2\\dfrac{m}{2}2m；

- 如果 mmm 为奇数，此时最小高度树的根节点为 pm+12p\_{\\frac{m+1}{2}}p2m+1，且此时最小的高度为 m−12\\dfrac{m-1}{2}2m−1。

因此我们只需要求出路径最长的两个叶子节点即可，并求出其路径的最中间的节点即为最小高度树的根节点。可以利用以下算法找到图中距离最远的两个节点与它们之间的路径：

- 以任意节点 ppp 出现，利用广度优先搜索或者深度优先搜索找到以 ppp 为起点的最长路径的终点 xxx；

- 以节点 xxx 出发，找到以 xxx 为起点的最长路径的终点 yyy；

- xxx 到 yyy 之间的路径即为图中的最长路径，找到路径的中间节点即为根节点。

上述算法的证明可以参考「[算法导论习题解答 9-1](https://leetcode-cn.com/link/?target=http%3A%2F%2Fcourses.csail.mit.edu%2F6.046%2Ffall01%2Fhandouts%2Fps9sol.pdf)」。在此我们利用广度优先搜索来找到节点的最长路径，首先找到距离节点 000 的最远节点 xxx，然后找到距离节点 xxx 的最远节点 yyy，然后找到节点 xxx 与节点 yyy 的路径，然后找到根节点。

**代码**

- Python3
- C++
- Java
- C#
- C
- JavaScript
- Golang

```
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]

        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
        parents = [0] * n

        def bfs(start: int):
            vis = [False] * n
            vis[start] = True
            q = deque([start])
            while q:
                x = q.popleft()
                for y in g[x]:
                    if not vis[y]:
                        vis[y] = True
                        parents[y] = x
                        q.append(y)
            return x
        x = bfs(0)  # 找到与节点 0 最远的节点 x
        y = bfs(x)  # 找到与节点 x 最远的节点 y

        path = []
        parents[x] = -1
        while y != -1:
            path.append(y)
            y = parents[y]
        m = len(path)
        return [path[m // 2]] if m % 2 else [path[m // 2 - 1], path[m // 2]]

```

```
class Solution {
public:
    int findLongestNode(int u, vector<int> & parent, vector<vector<int>>& adj) {
        int n = adj.size();
        queue<int> qu;
        vector<bool> visit(n);
        qu.emplace(u);
        visit[u] = true;
        int node = -1;

        while (!qu.empty()) {
            int curr = qu.front();
            qu.pop();
            node = curr;
            for (auto & v : adj[curr]) {
                if (!visit[v]) {
                    visit[v] = true;
                    parent[v] = curr;
                    qu.emplace(v);
                }
            }
        }
        return node;
    }

    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1) {
            return {0};
        }
        vector<vector<int>> adj(n);
        for (auto & edge : edges) {
            adj[edge[0]].emplace_back(edge[1]);
            adj[edge[1]].emplace_back(edge[0]);
        }

        vector<int> parent(n, -1);
        /* 找到与节点 0 最远的节点 x */
        int x = findLongestNode(0, parent, adj);
        /* 找到与节点 x 最远的节点 y */
        int y = findLongestNode(x, parent, adj);
        /* 求出节点 x 到节点 y 的路径 */
        vector<int> path;
        parent[x] = -1;
        while (y != -1) {
            path.emplace_back(y);
            y = parent[y];
        }
        int m = path.size();
        if (m % 2 == 0) {
            return {path[m / 2 - 1], path[m / 2]};
        } else {
            return {path[m / 2]};
        }
    }
};

```

```
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<Integer>();
        if (n == 1) {
            ans.add(0);
            return ans;
        }
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<Integer>();
        }
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }

        int[] parent = new int[n];
        Arrays.fill(parent, -1);
        /* 找到与节点 0 最远的节点 x */
        int x = findLongestNode(0, parent, adj);
        /* 找到与节点 x 最远的节点 y */
        int y = findLongestNode(x, parent, adj);
        /* 求出节点 x 到节点 y 的路径 */
        List<Integer> path = new ArrayList<Integer>();
        parent[x] = -1;
        while (y != -1) {
            path.add(y);
            y = parent[y];
        }
        int m = path.size();
        if (m % 2 == 0) {
            ans.add(path.get(m / 2 - 1));
        }
        ans.add(path.get(m / 2));
        return ans;
    }

    public int findLongestNode(int u, int[] parent, List<Integer>[] adj) {
        int n = adj.length;
        Queue<Integer> queue = new ArrayDeque<Integer>();
        boolean[] visit = new boolean[n];
        queue.offer(u);
        visit[u] = true;
        int node = -1;

        while (!queue.isEmpty()) {
            int curr = queue.poll();
            node = curr;
            for (int v : adj[curr]) {
                if (!visit[v]) {
                    visit[v] = true;
                    parent[v] = curr;
                    queue.offer(v);
                }
            }
        }
        return node;
    }
}

```

```
public class Solution {
    public IList<int> FindMinHeightTrees(int n, int[][] edges) {
        IList<int> ans = new List<int>();
        if (n == 1) {
            ans.Add(0);
            return ans;
        }
        IList<int>[] adj = new IList<int>[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new List<int>();
        }
        foreach (int[] edge in edges) {
            adj[edge[0]].Add(edge[1]);
            adj[edge[1]].Add(edge[0]);
        }

        int[] parent = new int[n];
        Array.Fill(parent, -1);
        /* 找到与节点 0 最远的节点 x */
        int x = FindLongestNode(0, parent, adj);
        /* 找到与节点 x 最远的节点 y */
        int y = FindLongestNode(x, parent, adj);
        /* 求出节点 x 到节点 y 的路径 */
        IList<int> path = new List<int>();
        parent[x] = -1;
        while (y != -1) {
            path.Add(y);
            y = parent[y];
        }
        int m = path.Count;
        if (m % 2 == 0) {
            ans.Add(path[m / 2 - 1]);
        }
        ans.Add(path[m / 2]);
        return ans;
    }

    public int FindLongestNode(int u, int[] parent, IList<int>[] adj) {
        int n = adj.Length;
        Queue<int> queue = new Queue<int>();
        bool[] visit = new bool[n];
        queue.Enqueue(u);
        visit[u] = true;
        int node = -1;

        while (queue.Count > 0) {
            int curr = queue.Dequeue();
            node = curr;
            foreach (int v in adj[curr]) {
                if (!visit[v]) {
                    visit[v] = true;
                    parent[v] = curr;
                    queue.Enqueue(v);
                }
            }
        }
        return node;
    }
}

```

```
int findLongestNode(int u, int * parent, const struct ListNode ** adj, int n) {
    int * queue = (int *)malloc(sizeof(int) * n);
    int head = 0, tail = 0;
    bool * visit = (bool *)malloc(sizeof(bool) * n);
    memset(visit, 0, sizeof(bool) * n);
    queue[tail++] = u;
    visit[u] = true;
    int res = -1;

    while (head != tail) {
        int curr = queue[head++];
        res = curr;
        struct ListNode * node = adj[curr];
        while (node) {
            if (!visit[node->val]) {
                visit[node->val] = true;
                parent[node->val] = curr;
                queue[tail++] = node->val;
            }
            node = node->next;
        }
    }
    free(queue);
    free(visit);
    return res;
}

int* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){
    int * res = NULL;
    if (n == 1) {
        res = (int *)malloc(sizeof(int));
        *res = 0;
        *returnSize = 1;
        return res;
    }

    struct ListNode ** adj = (struct ListNode *)malloc(sizeof(struct ListNode *) * n);
    for (int i = 0; i < n; i++) {
        adj[i] = NULL;
    }
    for (int i = 0; i < edgesSize; i++) {
        int u = edges[i][0];
        int v = edges[i][1];
        struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode));
        node->val = u;
        node->next = adj[v];
        adj[v] = node;
        node = (struct ListNode *)malloc(sizeof(struct ListNode));
        node->val = v;
        node->next = adj[u];
        adj[u] = node;
    }

    int * parent = (int *)malloc(sizeof(int) * n);
    /* 找到与节点 0 最远的节点 x */
    int x = findLongestNode(0, parent, adj, n);
    /* 找到与节点 x 最远的节点 y */
    int y = findLongestNode(x, parent, adj, n);
    /* 求出节点 x 到节点 y 的路径 */
    int * path = (int *)malloc(sizeof(int) * n);
    int pos = 0;
    parent[x] = -1;
    while (y != -1) {
        path[pos++] = y;
        y = parent[y];
    }
    if (pos % 2 == 0) {
        res = (int *)malloc(sizeof(int) * 2);
        res[0] = path[pos / 2 - 1];
        res[1] = path[pos / 2];
        *returnSize = 2;
    } else {
        res = (int *)malloc(sizeof(int));
        *res = path[pos / 2];
        *returnSize = 1;
    }
    free(path);
    free(parent);
    for (int i = 0; i < n; i++) {
        struct ListNode * node = adj[i];
        while (node) {
            struct ListNode * curr = node;
            node = curr->next;
            free(curr);
        }
    }
    free(adj);
    return res;
}

```

```
var findMinHeightTrees = function(n, edges) {
    const ans = [];
    if (n === 1) {
        ans.push(0);
        return ans;
    }
    const adj = new Array(n).fill(0).map(() => new Array());
    for (const edge of edges) {
        adj[edge[0]].push(edge[1]);
        adj[edge[1]].push(edge[0]);
    }

    const parent = new Array(n).fill(-1);
    /* 找到与节点 0 最远的节点 x */
    const x = findLongestNode(0, parent, adj);
    /* 找到与节点 x 最远的节点 y */
    let y = findLongestNode(x, parent, adj);
    /* 求出节点 x 到节点 y 的路径 */
    const path = [];
    parent[x] = -1;
    while (y !== -1) {
        path.push(y);
        y = parent[y];
    }
    const m = path.length;
    if (m % 2 === 0) {
        ans.push(path[Math.floor(m / 2) - 1]);
    }
    ans.push(path[Math.floor(m / 2)]);
    return ans;
}

const findLongestNode = (u, parent, adj) => {
    const n = adj.length;
    const queue = [];
    const visit = new Array(n).fill(false);
    queue.push(u);
    visit[u] = true;
    let node = -1;

    while (queue.length) {
        const curr = queue.shift();
        node = curr;
        for (const v of adj[curr]) {
            if (!visit[v]) {
                visit[v] = true;
                parent[v] = curr;
                queue.push(v);
            }
        }
    }
    return node;
};

```

```
func findMinHeightTrees(n int, edges [][]int) []int {
    if n == 1 {
        return []int{0}
    }

    g := make([][]int, n)
    for _, e := range edges {
        x, y := e[0], e[1]
        g[x] = append(g[x], y)
        g[y] = append(g[y], x)
    }

    parents := make([]int, n)
    bfs := func(start int) (x int) {
        vis := make([]bool, n)
        vis[start] = true
        q := []int{start}
        for len(q) > 0 {
            x, q = q[0], q[1:]
            for _, y := range g[x] {
                if !vis[y] {
                    vis[y] = true
                    parents[y] = x
                    q = append(q, y)
                }
            }
        }
        return
    }
    x := bfs(0) // 找到与节点 0 最远的节点 x
    y := bfs(x) // 找到与节点 x 最远的节点 y

    path := []int{}
    parents[x] = -1
    for y != -1 {
        path = append(path, y)
        y = parents[y]
    }
    m := len(path)
    if m%2 == 0 {
        return []int{path[m/2-1], path[m/2]}
    }
    return []int{path[m/2]}
}

```

**复杂度分析**

- 时间复杂度：O(n)，其中 nnn 是为节点的个数。图中边的个数为 n−1，因此建立图的关系需要的时间复杂度为 O(n)O(n)O(n)，通过广度优先搜索需要的时间复杂度为 O(n+n−1)O(n + n - 1)O(n+n−1)，求最长路径的时间复杂度为 O(n)O(n)O(n)，因此总的时间复杂度为 O(n)O(n)O(n)。

- 空间复杂度：O(n)O(n)O(n)，其中 nnn 是节点的个数。由于题目给定的图中任何两个顶点都只有一条路径连接，因此图中边的数目刚好等于 n−1n-1n−1，用邻接表构造图所需的空间刚好为 O(2×n)O(2 \\times n)O(2×n)，存储每个节点的距离和父节点均为 O(n)O(n)O(n)，使用广度优先搜索时，队列中最多有 nnn 个元素，所需的空间也为 O(n)O(n)O(n)，因此空间复杂度为 O(n)O(n)O(n)。

#### [](https://leetcode-cn.com/problems/minimum-height-trees/solution/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f//#方法二：深度优先搜索)方法二：深度优先搜索

**思路与算法**

方法一中使用广度优先搜索求出路径最长的节点与路径，我们还可以使用深度优先搜索来实现。首先找到距离节点 000 的最远节点 xxx，然后找到距离节点 xxx 的最远节点 yyy，然后找到节点 xxx 与节点 yyy 的路径，然后找到根节点。

**代码**

- Python3
- C++
- Java
- C#
- C
- JavaScript
- Golang

```
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]

        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
        parents = [0] * n
        maxDepth, node = 0, -1

        def dfs(x: int, pa: int, depth: int):
            nonlocal maxDepth, node
            if depth > maxDepth:
                maxDepth, node = depth, x
            parents[x] = pa
            for y in g[x]:
                if y != pa:
                    dfs(y, x, depth + 1)
        dfs(0, -1, 1)
        maxDepth = 0
        dfs(node, -1, 1)

        path = []
        while node != -1:
            path.append(node)
            node = parents[node]
        m = len(path)
        return [path[m // 2]] if m % 2 else [path[m // 2 - 1], path[m // 2]]

```

```
class Solution {
public:
    void dfs(int u, vector<int> & dist, vector<int> & parent, const vector<vector<int>> & adj) {
        for (auto & v : adj[u]) {
            if (dist[v] < 0) {
                dist[v] = dist[u] + 1;
                parent[v] = u;
                dfs(v, dist, parent, adj);
            }
        }
    }

    int findLongestNode(int u, vector<int> & parent, const vector<vector<int>> & adj) {
        int n = adj.size();
        vector<int> dist(n, -1);
        dist[u] = 0;
        dfs(u, dist, parent, adj);
        int maxdist = 0;
        int node = -1;
        for (int i = 0; i < n; i++) {
            if (dist[i] > maxdist) {
                maxdist = dist[i];
                node = i;
            }
        }
        return node;
    }

    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1) {
            return {0};
        }
        vector<vector<int>> adj(n);
        for (auto & edge : edges) {
            adj[edge[0]].emplace_back(edge[1]);
            adj[edge[1]].emplace_back(edge[0]);
        }
        vector<int> parent(n, -1);
        /* 找到距离节点 0 最远的节点  x */
        int x = findLongestNode(0, parent, adj);
        /* 找到距离节点 x 最远的节点  y */
        int y = findLongestNode(x, parent, adj);
        /* 找到节点 x 到节点 y 的路径 */
        vector<int> path;
        parent[x] = -1;
        while (y != -1) {
            path.emplace_back(y);
            y = parent[y];
        }
        int m = path.size();
        if (m % 2 == 0) {
            return {path[m / 2 - 1], path[m / 2]};
        } else {
            return {path[m / 2]};
        }
    }
};
```
