# 2 词法分析（Lexical Analysis）

- 编译器的前端：执行分析，把程序的各种成分拆开， 并搞清其结构和含义．
  - 词法分析：单词
  - 语法分析：短语结构
  - 语义分析：程序的含义
- 编译器的后端：进行合成，把这些成分组合起来．

词法分析器以字符流作为输入，生成一系列的名字、关键字和标点符号，同时抛弃单词之间的空白符和注释。

词法分析并不太复杂，但是我们却使用能力强大的形式化方法和工具来实现它，因为类似的形式化方法对语法分析研究很有帮助，并且类似的工具还可以应用于编译器以外的其他领域。

## 2.1 词法单词（Lexical Token）

词法单词是字符组成的序列，可以将其看作程序设计语言的文法单位。程序设计语言的词法单词可以归类为有限的几组单词类型。

![图 1](../../../.media/a3010ded714f5c739ce3e10dfa6d934648edb04cf8a9081058fe49817b2fb8e2.png)  

像 IF 、 VOID 、 RETURN 这样的由字符组成的 punctuation token 称为保留字（reserved word），在绝大多数语言中不能作为标识符（identifier）．

一些语言需要宏预处理，在词法分析之前进行，两者也可以集成到一起．

![图 2](../../../.media/112490c7e487e4fb8516efb1c34adeb6f0c46b166e863a65ff64ed64db078b8c.png)  
![图 3](../../../.media/360d7119a07cc245d7a5474a285a9cf6210a667d37e1c663dd8ba04101ce73c4.png)  

词法分析器报告了每个单词的单词类型和一些附加信息。一些单词（如标识符和字面量）有「语义值」与之相连．

用正则表达式这种形式化语言来指明词法单词，用确定的有限自动机（deterministic finite automata）来实现词法分析器，并用数学的方法将两者联系起来。

## 2.2 正则表达式

1. 语言（language）：字符串组成的集合．
2. 字符串：符号（symbol）的有限序列．
3. 符号：来自有限的字母表（alphabet）．

正则表达式的基本操作符：

1. 符号（symbol）：一个符号，比如 $a$ ．
2. 可选（alternation）：$|$ ，即「或」．
3. 联结（concatenation）：$a \cdot b$ ，可省略为 $ab$ ．
4. $\epsilon$ （epsilon）：空字符串，可省略．
5. 克林闭包（Kleene closure）：$a^{*}$ ，把 $a$ 重复 0 ~ n 次，优先级高于联结运算．

正则表达式的记号（没有扩充正则表达式的描述能力，任何简写形式都可以用基本操作符来描述）：

![图 2](../../../.media/cf90dafb0245fdcaa19582dc0108fbac550866fbb93a3da2a958167059cc627c.png)  

一些单词的正则表达式：

![图 2](../../../.media/24e3a68cce98d59cb535818b0ec7f35678a1dc9881d85aa028518abc9894e9a7.png)  

1. 注释会被识别，但不提交给语法分析器．
2. 词法规范应当是完整的，它应总是能与输入的某个子串匹配．因此要有一个表示 error 的规则．

为了消除二义性，还应使用两条规则：

1. 最长匹配：选择匹配最长的字符串．
2. 规则优先：规则有优先级．

## 2.3 有限自动机（Finite Automata）

有限自动机的作用：形式化的方式在程序中实现正则表达式．

有限自动机：

1. 有限的状态集
2. 边从一个状态指向另一个状态．
3. 每条边都标记有一个符号．
4. 1 个初态．
5. 1 ~ n 个终态．

![图 3](../../../.media/67e8dd14913b0a03d9ce559ab2c1163ac53b13b4382745736aac0971cedf5856.png)  
