# 1 从可执行文件到库

## 1.1 将单个源文件编译为可执行文件

CMake 中，C++是默认的编程语言。不过，我们还是建议使用 LANGUAGES 选项在 project 命令中显式地声明项目的语言。

创建一个目录 build 并进入，然后指定 CMakeLists.txt 的位置，调用 CMake ．

```shell
cmake . -B build
```

- . 表示在当前目录中搜索 CMakeLists.txt 文件.
- -B build 告诉 CMake 在一个名为 build 的目录中生成所有的文件。

CMake 是一个构建系统生成器。将描述构建系统(如：Unix Makefile、Ninja、Visual Studio 等)应当如何操作才能编译代码。然后，CMake 为所选的构建系统生成相应的指令。GNU/Linux 上，CMake 默认生成 Unix Makefile 来构建项目．

build 中的内容：

- Makefile: make 将运行指令来构建项目。
- CMakefile：包含临时文件的目录，CMake 用于检测操作系统、编译器等。此外，根据所选的生成器，它还包含特定的文件。
- cmake_install.cmake：处理安装规则的 CMake 脚本，在项目安装时使用。
- CMakeCache.txt：如文件名所示，CMake 缓存。CMake 在重新运行配置时使用这个文件。

构建示例项目：

```shell
cmake --build build
```

显示所有的 target：

```shell
cmake --build build --target help
```

- all(或 Visual Studio generator 中的 ALL_BUILD)是默认目标，将在项目中构建所有目标。
- clean，删除所有生成的文件。
- rebuild_cache，将调用 CMake 为源文件生成依赖(如果有的话)。
- edit_cache，这个目标允许直接编辑缓存。
- test(或 Visual Studio generator 中的 RUN_TESTS)将在 CTest 的帮助下运行测试套件。
- install，将执行项目安装规则。
- package，此目标将调用 CPack 为项目生成可分发的包。

## 1.2 切换生成器

CMake 是**构建系统的生成器**．显示所有的可用生成器：

```shell
cmake --help
```

切换生成器为 Ninja．

```shell
cmake . -B build -G Ninja
cmake --build build
```

## 1.3 构建和链接静态库和动态库

add_library 的第 2 个参数：

- STATIC：用于创建静态库，即编译文件的打包存档，以便在链接其他目标时使用，例如：可执行文件。
- SHARED：用于创建动态库，即可以动态链接，并在运行时加载的库。可以在 CMakeLists.txt 中使用 `add_library(message SHARED Message.hpp Message.cpp)` 从静态库切换到动态共享对象(DSO)。
- OBJECT：可将给定 add_library 的列表中的源码编译到目标文件，不将它们归档到静态库中，也不能将它们链接到共享对象中。如果需要一次性创建静态库和动态库，那么使用对象库尤其有用。我们将在本示例中演示。
- MODULE：又为 DSO 组。与 SHARED 库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建运行时插件。能否链接到 DSO 这取决于操作系统和编译器：

  - GNU/Linux 和 macOS 上，不管选择什么编译器，它都可以工作。
  - Windows 上，不能与 Visual Studio 兼容，但可以与 MinGW 和 MSYS2 兼容。

  生成好的 DSO 组需要程序员限制符号的可见性，并在编译器的帮助下实现，但在不同的操作系统和编译器上约定不同。CMake 有一个机制来处理这个问题．

CMake 还能够生成特殊类型的库，这不会在构建系统中产生输出，但是对于组织目标之间的依赖关系，和构建需求非常有用：

- IMPORTED：此类库目标表示位于项目外部的库。此类库的主要用途是，对现有依赖项进行构建。因此，IMPORTED 库将被视为不可变的。
- INTERFACE：与 IMPORTED 库类似。不过，该类型库可变，没有位置信息。它主要用于项目之外的目标构建使用。
- ALIAS：顾名思义，这种库为项目中已存在的库目标定义别名。不过，不能为 IMPORTED 库选择别名。

## 1.4 用条件句控制编译

> ####
>
> CMake 语言相当庞杂，由基本的控制结构、特定于 CMake 的命令和使用新函数模块化扩展语言的基础设施组成。完整的概览可以在这里找到: <https://cmake.org/cmake/help/latest/manual/cmake-language.7.html>​

使用条件语句在两个行为之间切换：

1. 将 Message.hpp 和 Message.cpp 构建成一个库(静态或动态)，然后将生成库链接到 hello-world 可执行文件中。
2. 将 Message.hpp，Message.cpp 和 hello-world.cpp 构建成一个可执行文件，但不生成任何一个库。

在 GNU/Linux 上，运行 `objdump -x` 命令进行验证。

### 逻辑变量

- 逻辑变量为 true ：1、ON、YES、true、Y 或非零数．
- 逻辑变量为 false ：0、OFF、NO、false、N、IGNORE、NOTFOUND、空字符串，或者以 -NOTFOUND 为后缀．

### BUILD_SHARED_LIBS

BUILD_SHARED_LIBS 是 CMake 的一个全局标志。因为 CMake 内部要查询 BUILD_SHARED_LIBS 全局变量，所以 add_library 命令可以在不传递 STATIC/SHARED/OBJECT 参数的情况下调用；如果为 false 或未定义，将生成一个静态库。

## 1.5 向用户显示选项

在 CMakeLists.txt 中使用 option() 命令，以选项的形式显示逻辑开关，用于外部设置，从而切换构建系统的生成行为。

-D 用于为 CMake 设置任何类型的变量：逻辑变量、路径等。

还有 cmake_dependent_option() ,这种选项以其他的选项作为前提，这个模块需要先 include ．

在命令行中可以查看模块的帮助．

```sh
cmake --help-module <name-of-module>
```

## 1.6 指定编译器

CMake 将语言的编译器存储在 `CMAKE_<LANG>_COMPILER` 变量中，其中 `<LANG>` 是受支持的任何一种语言，对于我们的目的是 CXX、C 或 Fortran ．

使用 CLI 中的 -D 选项设置此变量：

```sh
cmake . -D CMAKE_CXX_COMPILER=clang++ -B build
```

CMake 在标准路径中执行查找编译器。如果不是这样，用户将需要将完整的编译器可执行文件或包装器路径传递给 CMake。

配置时，CMake 会进行一系列平台测试，以确定哪些编译器可用，以及它们是否适合当前的项目。一个合适的编译器不仅取决于我们所使用的平台，还取决于我们想要使用的生成器。

CMake 提供--system-information 标志，它将把关于系统的所有信息转储到屏幕或文件中。

```sh
cmake --system-information information.txt
```

文件中可以看到 CMAKE_CXX_COMPILER、CMAKE_C_COMPILER 和 CMAKE_Fortran_COMPILER 的默认值，以及默认标志。
