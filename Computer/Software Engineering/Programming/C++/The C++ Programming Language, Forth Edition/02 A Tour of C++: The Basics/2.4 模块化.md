## 2.4 模块化 / Modularity

C++ 使用声明来描述接口，声明和定义可以分离．

### 2.4.1 分离编译 / Separate Compilation

C+＋ 支持分离编译，用户代码只能看见所用类型和函数的声明（.h），它们的定义则放置在分离的源文件里（.cpp），并被分别编译。

![图 1](../../../../../../.media/250e03c15d33b21059b22acd2a7561cf2c7914dd49b828cb392ac7211817e3d7.png)  

### 2.4.2 名字空间 / Namespaces

不同名字空间内的名字不会相互冲突．名字空间主要用于组织较大规模的程序组件，最典型的例子是库。使用名字空间，我们就可以很容易地把若干独立开发的部件组织成一个程序。

### 2.4.3 错误处理 / Error Handling

#### 2.4.3.1 异常 / Exceptions

`throw` 负责把程序的控制权从某个直接或间接调用了 `Vector::operator[]()` 的函数转移到 `out_ of_range` 异常处理代码。为了完成这一目标，实现部分需要展开函数调用栈以便返回主调函数的上下文．

![图 2](../../../../../../.media/d50bb7313efb93556dace4b39065f228d07294e6a0345eb6d0b44678013dd7c8.png)  

#### 2.4.3.2 不变式 / Invariants

使用异常机制通报越界访问错误是函数检查实参的一个示例，此时，因为基本假设，即所谓的前置条件 （precondition）没有得到满足，所以函数将拒绝执行。

对于类来说，这样一条假定某事为真的声明称为类的不变式（class invariant），简称为不变式（invariant）。建立类的不变式是构造函数的任务，从而成员函数可以依赖于该不变式，当成员函数退出时不变式仍应成立。

通常情况下，当遭遇异常后函数就无法继续完成工作了。此时，“处理”异常的含义仅仅是做一些简单的局部资源清理，然后重新抛出异常。

不变式的概念是设计类的关键，而前置条件也在设计函数的过程中起到同样的作用。不变式

- 帮助我们准确地理解想要什么．
- 强制要求具体而明确地描述设计，而这有助于确保代码正确（在调试和测试之后）．

不变式的概念是 C++ 当中由构造函数和析构函数支撑的资源管理概念的基础．

#### 2.4.3.3 静态断言

`static_assert(A,S)` 的作用是当 `A` 不为 true 时，把 `S` 作为一条编译器错误信息输出。

`static_assert` 最重要的用途是为泛型编程中作为形参的类型设置断言．
