# 2 Data Types

预定义类型（predefined types）

基元类型（primitive types）

## 2.1 基本数值类型

### 2.1.1 整数类型

![图 5](../../../../../.media/ed022d86cdb2b29878ddd3cc30cce381545fdfe5d8c65b93bd81fe946cca4851.png)

C# 所有基元类型都有短名称和完整名称。完整名称对应 BCL（基类库）中的类型名称。该名称在所有语言中都相同，对程序集中的类型进行了唯一性标识。由于基元数据类型是其他类型的基础，所以 C# 为基元数据类型的完整名称提供了短名称 （或称为缩写）。其实从编译器的角度看，两种名称完全一样，最终都生成相同的代码。事实上，检查最终生成的 CIL 代码，根本看不出源代码具体使用的名称。

设计规范：

1. 要一致．
2. 使用 C# 关键字而不是 BCL 名称．

C/C++ 的 short 数据类型是 short int 的缩写。而 C# 的 short 是一种实际存在的数据类型。

### 2.1.2 浮点类型（float 和 double）

![图 2](../../../../../.media/aa6ffdf4887d98f1a2910564d83029cd59d6f6f5e992cfd1e787c97658ce2d4d.png)

### 2.1.3 Decimal Type

![图 4](../../../../../.media/281f23a84fdcc1361b9a83438042c177e33cd9fc00e6e9b99565d49fe88f62a0.png)

decimal 被表示成 $±N×10^k$ ；其中 N 是 96 位的正整数，而 $-28<=k<=0$。

而浮点数是 $±N×2 k$ 的任意数字。其中，N 是用固定数量位数 （float 是 24，double 是 53）表示的正整数，k 是-149 ～+104（float） 或者-1075 ～+970（double）的任何整数。

### 2.1.4 字面值（Literal Value）

即“字面上写出来的值”．

数字分隔符：

```csharp
System.Console.WriteLine(9_814_072_356);
```

16 进制：

```csharp
System.Console.WriteLine(0X002A);
```

```
42
```

2 进制：

```csharp
System.Console.WriteLine(0B101010);
```

#### 字面值的格式化

指数计数法：

```csharp
System.Console.WriteLine(6.023E23F);
```

```
6.023E+23
```

格式化成 16 进制：

```csharp
System.Console.WriteLine($"0X{42:X}");
```

```
0X2A
```

其他的格式化：<https://docs.microsoft.com/en-us/dotnet/standard/base-types/formatting-types> ．

设计规范：

1. 使用大写的字面值后缀．

## 2.2 更多基本类型

### 2.2.1 布尔类型（bool）

虽然理论上一个二进制位足以容纳一个布尔类型的值，但 bool 实际大小是一个字节．

### 2.2.2 字符类型（char）

字符类型 char 表示 16 位字符，取值范围对应于 Unicode 字符集。

Unicode 是一个国际性标准，用来表示大多数语言中的字符。它便于计算机系统构建本地化应用程序，为不同语言文化显示具有本地特色的字符更加方便。

不是所有 Unicode 字符都能用一个 16 位 char 表示。刚开始提出 Unicode 的概念时，它的设计者以为 16 位已经足够。但随着支持的语言越来越多，才发现当初的假定是错误的。结果是，一些 Unicode 字符要由一对称为“代理项”的 char 构成，总共 32 位。

![图 1](../../../../../.media/33c3d778d165e49b8042c52cfe91bb2058165dd20d67912c52cc72aa7848b4d3.jpg)

可用 Unicode 编码表示任何字符。为此，请为 Unicode 值附加 \u 前缀。可用 16 进制记数法表示 Unicode 字符。

### 2.2.3 字符串

#### 字面值

不能将换行符直接插入不以 @ 符号开头的字符串中。

C# 允许在字符串前使用 @ 符号，指明转义序列不被处理。结果是一个逐字字符串字面值（verbatim string literal），它不仅将反斜杠当作普通字符，还会逐字解释所有空白字符。

以 @ 开头的字符串唯一支持的转义序列是 "" ，代表一个双引号，不会终止字符串。

和 C++不同，C#不自动连接字符串字面值。

不能像下面这样指定字符串字面值：

"Major Strasser has been shot."

"Round up the usual suspects."

必须用 + 操作符连接（但如果编译器能在编译时计算结果，最终的 CIL 代码将包含连接好的字符串）。

假如同一字符串字面值在程序集中多次出现，编译器在程序集中只定义字符串一次，且所有变量都指向它。这样一来，假如在代码中多处插入包含大量字符的同一个字符串字面值，最终的程序集只反映其中一个的大小。

#### 字符串插值

在字符串前添加 $ 符号，并在字符串中用一对大括号嵌入表达式。

`$` 和 `@` 可同时使用．

字符串插值是 `string.Format()` 的语法糖．

#### string 的静态方法

![图 1](../../../../../.media/63fc6399fb43a7fb20ee314b10eb31425b7d47e4bc1b311472bc428da6f08c21.jpg)  
![图 1](../../../../../.media/35f54da857c2d24002649cbdc678b58f6302be6cfead3c1fbd5bd046c8ac53c1.jpg)

要在插值或格式化的字符串中添加实际的左右大括号，可连写两个大括号来表示。

调用静态方法需附加命名空间和类型名前缀，可利用 C#6.0 新增的 `using static` 指令避免这些前缀．

`using` 指令用于省略命名空间前缀（例如 System）．using 作用于它所在的整个文件（或命名空间），而非仅作用于静态成员。

#### string 的实例方法

![图 1](../../../../../.media/23c42981b4542dbe280e42929863904cb642ddfccbb4c0e8e54d34629280c667.jpg)  
![图 2](../../../../../.media/5f364d549215844bbe458a458fad66af44f3121b96594f72e8c00f2769b90938.jpg)

#### 换行符

依赖 `System.WriteLine()` 和 `System.Environment.NewLine` 而不是 `\n` 来确保跨平台兼容．

#### 字符串的 Length 成员

判断字符串长度可以使用 string 的 Length 成员。该成员是只读属性 。不能设置，调用时也不需要任何参数。字符串长度不能直接设置，它是根据字符串中的字符数计算得到的。此外，字符串长度不能更改，因为字符串不可变 。

Length 成员不是方法，因为调用时没有使用圆括号。Length 是 string 的属性 （property），C# 语法允许像访问成员变量（在 C# 中称为字段）那样访问属性。属性定义了称为赋值方法（setter）和取值方法（getter）的特殊方法，但用字段语法访问那些方法。

研究属性的底层 CIL 实现，发现它编译成两个方法：`set_<PropertyName>` 和 `get_<PropertyName>` 。但这两个方法不能直接从 C# 代码中访问，只能通过 C# 属性构造来访问。

#### 字符串不可变

string 类型的一个关键特征是它不可变 （immutable）。可为 string 变量赋一个全新的值，但出于性能考虑，没有提供修改现有字符串内容的机制。所以，不可能在同一个内存位置将字符串中的字母全部转换为大写。只能在其他内存位置新建字符串，让它成为旧字符串大写字母版本，旧字符串在这个过程中不会被修改，如果没人引用它，会被垃圾回收。

#### `System.Text.StringBuilder`

如有大量字符串需要修改，比如要经历多个步骤来构造一个长字符串，可考虑使用 `System.Text.StringBuilder` 类型，这种类型会修改自身，而不是返回新字符串．

## 2.3 null 和 void

### null

C# 规定变量在使用前一定要被赋值，但如果变量没有有效的值，就用 null 值来表示．

#### ?

在类型后加 ? 说明是 nullable 的，即可以被赋 null 值．

### void

void 用来指明类型的缺失．

## 2.4 数据类型转换 / CONVERSIONS BETWEEN DATA TYPES

数值不能转换成布尔值．

### 2.4.1 显示转型 / Explicit Cast

有可能造成数据丢失或引发异常（因为转换失败）的任何转换都需要执行显式转型．

执行显式转换时，如数据未能成功转换，“运行时”还是会引发异常。所以，要由程序员负责确保数据成功转换，或提供错误处理代码来处理转换不成功的情况。

#### checked 和 unchecked

控制“运行时”发生数据转换失败时是否引发异常．

可以在编译器选项设置，也可在代码中写 checked / unchecked 块．

### 2.4.2 隐式转型 / Implicit Conversion

不会丢失数据，而且不会引发异常（无论操作数的类型是什么）的任何转换都可以进行隐式转型．

### 2.4.3 不使用转型操作符的类型转换

- 字符串到数值：`Parse()`
- 所有类型字符串：`ToString()`
- 来回都行：`System.Convert`

大多数类型的 `ToString()` 方法只是返回数据类型的名称，而不是数据的字符串表示。只有在类型显式实现了`ToString()` 的前提下才会返回字符串表示。

`TryParse()` 失败返回 `false` ，不引发异常．
