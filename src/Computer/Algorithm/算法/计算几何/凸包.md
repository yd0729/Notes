# 凸包

向量叉乘：

- 结果是一个向量，方向为右手定则中大拇指的方向．
- 向量的夹角指的是按照右手定则，从第 1 个向量转到第 2 个向量的角度．
- 当两向量的夹角 $< \pi$ 时，结果 $> 0$ ．
- 当两向量的夹角 $> \pi$ 时，结果 $< 0$ ．
- 当两向量的夹角 $= \pi$ 时（平行），结果 $= 0$ ．

## Jarvis 算法

1. 找到左下点 a （一定在凸包上）．
2. 找到未加入闭包的 b ，满足其他的点都在 ab 的左（右）侧，否则结束．
3. 把 b 加入闭包，把 b 当做 a ，重复 2

注意：如果起始的 a 只是最左的点而不是左下的点，在处理共线时会比较麻烦．

- Time: $\mathcal{O}(n^2)$
- Space: $\mathcal{O}(n)$

## Graham 算法

1. 找到最下（左）侧的点 a （一定在凸包上）．
2. 以 a 为原点，以 x 轴（y 轴）为极轴，按照角度从小到大对其他点排序，对于角度相同的，按照到原点的距离从小到大排序．
3. 但是如果角度最大的点不唯一，要按照到原点的距离从大到小排序．
4. 把原点和第 1 个点压入栈中．
5. 遍历剩下的点，同时维护一个单调栈，如果当前点在次栈顶和栈顶构成的向量的左侧，则压入栈中，否则弹出栈顶．
6. 栈中的点就是凸包．

- Time: $\mathcal{O}(n\log n)$
- Space: $\mathcal{O}(n)$

## Andrew 算法

1. 把所有点按照 x 排序，如果 x 相同则按照 y 排序，最小和最大的点一定在凸包上．
2. 从最小的点出发，维护单调栈，到达最大的点，可以构造下凸壳．
3. 从最大的点出发，维护单调栈，到达最小的点，可以构造上凸壳．

- Time: $\mathcal{O}(n\log n)$
- Space: $\mathcal{O}(n)$

注意：这种排序方式不需要特判共线的点．
