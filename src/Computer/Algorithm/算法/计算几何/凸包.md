# 凸包

向量叉乘：

- 结果是一个向量，方向为右手定则中大拇指的方向．
- 向量的夹角指的是按照右手定则，从第 1 个向量转到第 2 个向量的角度．
- 当两向量的夹角 $< \pi$ 时，结果 $> 0$ ．
- 当两向量的夹角 $> \pi$ 时，结果 $< 0$ ．
- 当两向量的夹角 $= \pi$ 时（平行），结果 $= 0$ ．

LeetCode 587 考虑共线的点，LeetCode 812 不考虑共线的点，但要求凸包的点一定按照顺（逆）时针．

下面的算法考虑共线的点．

## Jarvis 算法

1. 找到最左下点 a0 ，令 a = a0 ．
2. 找到 b ，满足其他的点都不在 ab 的右（左）侧，如果 b 不在凸包，把 b 加入凸包．
4. 判断是否有与 ab 共线的点，如果有，加入凸包（如果想要保证最终得到的凸包的点是逆（顺）时针，还要对共线的点排序）．
5. 令 b = a
6. 如果 b ≠ a0 ，重复 2 ，否则结束．

- Time: $\mathcal{O}(n^2)$
- Space: $\mathcal{O}(n)$

## Graham 算法

1. 找到最下（左）点 a ．
2. 以 a 为原点，以 x 轴（y 轴）为极轴，按照角度从小到大对其他点排序，对于角度相同的，按照到原点的距离从小到大排序．
3. 如果角度最大的点不唯一，按照到原点的距离从大到小排序（把上次排序的结果翻转）．
4. 把原点和第 1 个点压入栈中．
5. 遍历剩下的点，同时维护一个单调栈，如果当前点在次栈顶和栈顶构成的向量的左侧，则压入栈中，否则弹出栈顶．
6. 栈中的点就是凸包．

- Time: $\mathcal{O}(n\log n)$
- Space: $\mathcal{O}(n)$

## Andrew 算法

1. 把所有点按照 x 从小到大排序，如果 x 相同则按照 y 从小到大排序，最小和最大的点一定在凸包上．
2. 从最小的点出发，维护不严格单调的单调栈，到达最大的点，可以构造下凸壳．
3. 从最大的点出发，维护不严格单调的单调栈，到达最小的点，可以构造上凸壳．
4. 在计算下凸壳时需要维护一个 used 记录加入凸包的点，在计算上凸壳时不能重复加入（比如所有的点是一条线的情况）．

- Time: $\mathcal{O}(n\log n)$
- Space: $\mathcal{O}(n)$

## 注意

如果不考虑共线的点：

1. Jarvis 算法
    1. 不需要维护 visit
    2. 在步进时遇到共线的点时选最远的．
    3. 不需要找共线的点
2. Graham 算法：
    1. 不需要翻转．
    2. 单调栈严格单调．
3. Andrew 算法：
    1. 不需要维护 visit ．
    2. 单调栈严格单调．

不考虑共线的点时，这 3 种算法得到的凸包的点都是顺（逆）时针的．
