# Welcome to Swift

## About Swift

- 变量始终在使用前初始化．
- 检查数组索引超出范围的错误．
- 检查整数是否溢出．
- 可选值确保明确处理 `nil` 值．
- 内存自动管理．
- 错误处理允许从意外故障控制恢复．

## Version Compatibility

以下功能仅支持 Swift 5.6 或更高版本:

- 返回值是不透明类型（opaque type）的函数依赖 Swift 5.1 运行时．
- `try?` 表达式不会为已返回可选类型的代码引入额外的可选类型层级．
- 大数字的整型字面量初始化代码的类型将会被正确推导，例如 **UInt64(0xffff_ffff_ffff_ffff)** 将会被推导为整型类型而非溢出．

并发特性需要 Swift 5.6 及以上版本，以及一个提供了并发相关类型的 Swift 标准库版本．要应用于苹果平台，请至少将部署版本设置为 iOS 15、macOS 12、tvOS 15 或 watchOS 8.0．

用 Swift 5.6 写的项目可以依赖用 Swift 4.2 或 Swift 4 写的项目，反之亦然．这意味着，如果你将一个大的项目分解成多个框架（framework），你可以逐个地将框架从 Swift 4 代码迁移到 Swift 5.5．

## A Swift Tour

全局作用域中的代码会被自动当做程序的入口点，所以不需要 `main()` 函数．同样不需要在每个语句结尾写上分号．

### Simple Values

#### 常量和变量

使用 `let` 来声明常量，使用 `var` 来声明变量．不需要在编译时明确给出常量的值，但是常量只能被赋值一次．

编译器会自动推断类型．

#### 字符串

没有隐式类型转换．

把值转换成字符串的简单的方法是把值写到括号中，并且在括号之前写一个反斜杠（\）．

使用三个双引号（`"""`）来包含多行字符串内容．每行行首的缩进会被去除到和结尾引号的缩进相匹配的位置．

#### 数组和字典

使用方括号 `[]` 来创建数组和字典，并使用下标或者键（key）来访问元素．最后一个元素后面允许有一个逗号．

数组会自动增长

使用初始化语法来创建空数组或者空字典．

可以推断类型时可以不写类型（作为函数的参数、给变量赋值等）．

### Control Flow

没有隐式转换， `if` 后必须是一个布尔表达式．

可以使用 `if` 和 `let` 来处理值缺失的情况．这些值可由可选值来代表．一个可选的值是一个具体的值或者是 `nil` 以表示值缺失．在类型后面加一个问号（`?`）来标记这个变量的值是可选的．

如果变量的可选值是 `nil`，条件会判断为 `false`，大括号中的代码会被跳过．如果不是 `nil`，会将值解包并赋给 `let` 后面的常量，这样代码块中就可以使用这个值了．

另一种处理可选值的方法是通过使用 `??` 操作符来提供一个默认值．如果可选值缺失的话，可以使用默认值来代替．

`switch` 支持任意类型的数据以及各种比较操作，但一定要有 `default` ．

运行 `switch` 中匹配到的 `case` 语句之后，程序会退出 `switch` 语句，并不会继续向下运行，所以不需要在每个子句结尾写 `break`．

`for-in` 可以用来遍历字典，字典是无序的，所以它们的键和值以任意顺序迭代结束．

使用 `while` 来重复运行一段代码直到条件改变．循环条件也可以在结尾，保证能至少循环一次．

`...` 闭区间，`..<` 左闭右开

### Functions and Closures

使用 `func` 来声明一个函数，使用名字和参数来调用函数．使用 `->` 来指定函数返回值的类型．

默认情况下，函数使用它们的参数名称作为它们参数的 label ，在参数名称前可以自定义 label ，或者使用 `_` 表示不使用参数标签．

元组可以用来生成复合值，作为函数的返回值．元组的元素可以通过名称或数字来引用．

函数可以嵌套．被嵌套的函数可以访问外侧函数的变量，你使用嵌套函数可以重构一个太长或者太复杂的函数．

函数是一级类型，即函数可以作为返回值或参数．

函数可以看做是稍后可以调用的代码块，是闭包的特殊情况．闭包中的代码可以访问在创建闭包的范围内可用的变量和函数等内容，即使闭包在执行时处于不同的范围内，比如嵌套函数．将代码用大括号 `{}` 包包起来就可以编写没有名称的闭包． `in` 将参数和返回类型与 body 分开．

当闭包的类型已知时，例如委托的回调，您可以省略其参数的类型、返回类型．单个语句的闭包隐式返回其唯一语句的值．

可以按数字而不是名称引用参数，这种方法在非常短的闭包中特别有用．作为函数最后一个参数传递的闭包可以写在括号之后．如果闭包是函数的唯一参数，函数的小括号可以省略．

### Objects and Classes

属性和变量的写法是一样的，方法和函数的写法是一样的，唯一的区别就是它们的上下文是类．

`init` 是用来初始化实例的方法．所有的属性都需要被赋值，赋值可以在声明时完成，也可以在初始化器中完成．`deinit` 是用来销毁实例的方法．

简单的属性可以直接存储，复杂的属性可以用 getter 和 setter ．

如果您不需要计算属性，但仍然需要提供在设置新值之前和之后运行的代码，请使用 `willSet` 和 `didSet`．每当值在初始化器之外更改时，您提供的代码都会运行．

当使用可选值时，可以在方法、属性和下标之前添加`?`，如果可选值是`nil`，那么`?`之后的任何操作都会被忽略，整个表达式的值是`nil`．否则这个可选值会被解封，并且在`?`之后一直有效．总的来说，带有`?`的表达式的值是一个可选值．

### Enumerations and Structures

```swift
enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king

    func simpleDescription() -> String {
        switch self {
        case .ace:
            return "ace"
        case .jack:
            return "jack"
        case .queen:
            return "queen"
        case .king:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
```

默认从 0 开始，也可以自定义，也可以用初始化器`init?(rawValue:)`从 `rawValue` 创建枚举值．如果不存在匹配的枚举值，那么就返回`nil`．

```swift
if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
```
